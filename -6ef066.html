<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<!-- iOS Safari -->
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<!-- Chrome, Firefox OS and Opera Status Bar Color -->
<meta name="theme-color" content="#FFFFFF">
<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css">
<link rel="stylesheet" type="text/css"
  href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.19.0/themes/prism.min.css">
<link rel="stylesheet" type="text/css" href="css/SourceSansPro.css">
<link rel="stylesheet" type="text/css" href="css/theme.css">
<link rel="stylesheet" type="text/css" href="css/notablog.css">
<!-- Favicon -->

  <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text text-anchor=%22middle%22 dominant-baseline=%22middle%22 x=%2250%22 y=%2255%22 font-size=%2280%22&gt;📖&lt;/text&gt;&lt;/svg&gt;">

<style>
  :root {
    font-size: 20px;
  }
</style>
  <title>ALGORITHM&nbsp;|&nbsp;Welcome to Robin’s Blog</title>
  <meta property="og:type" content="blog">
  <meta property="og:title" content="ALGORITHM">
  
    <meta name="description" content="一些常见算法的总结。">
    <meta property="og:description" content="一些常见算法的总结。">
  
  
    <meta property="og:image" content="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text text-anchor=%22middle%22 dominant-baseline=%22middle%22 x=%2250%22 y=%2255%22 font-size=%2280%22&gt;🎃&lt;/text&gt;&lt;/svg&gt;">
  
  <style>
    .DateTagBar {
      margin-top: 1.0rem;
    }
  </style>
</head>

<body>
  <nav class="Navbar">
  <a href="index.html">
    <div class="Navbar__Btn">
      
        <span><img class="inline-img-icon" src="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text text-anchor=%22middle%22 dominant-baseline=%22middle%22 x=%2250%22 y=%2255%22 font-size=%2280%22&gt;📖&lt;/text&gt;&lt;/svg&gt;"></span>&nbsp;
      
      <span>Home</span>
    </div>
  </a>
  
    
  
    
  
    
  
    
  
    
  
    
      <span class="Navbar__Delim">&centerdot;</span>
      <a href="-d98406.html">
        <div class="Navbar__Btn">
          
            <span><img class="inline-img-icon" src="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text text-anchor=%22middle%22 dominant-baseline=%22middle%22 x=%2250%22 y=%2255%22 font-size=%2280%22&gt;😀&lt;/text&gt;&lt;/svg&gt;"></span>&nbsp;
          
          <span>About ME</span>
        </div>
      </a>
    
  
    
  
</nav>
  <header class="Header">
    
      <div class="Header__Cover">
        <img src="https://images.unsplash.com/photo-1450149632596-3ef25a62011a?ixlib=rb-4.0.3&amp;q=80&amp;fm=jpg&amp;crop=entropy&amp;cs=tinysrgb">
      </div>
    
    <div class="Header__Spacer ">
    </div>
    
      <div class="Header__Icon">
        <span><img class="inline-img-icon" src="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text text-anchor=%22middle%22 dominant-baseline=%22middle%22 x=%2250%22 y=%2255%22 font-size=%2280%22&gt;🎃&lt;/text&gt;&lt;/svg&gt;"></span>
      </div>
    
    <h1 class="Header__Title">ALGORITHM</h1>
    
      <div class="DateTagBar">
        
          <span class="DateTagBar__Item DateTagBar__Date">Posted on Mon, Feb 27, 2023</span>
        
        
          <span class="DateTagBar__Item DateTagBar__Tag DateTagBar__Tag--pink">
            <a href="tag/计算机基础.html">计算机基础</a>
          </span>
        
          <span class="DateTagBar__Item DateTagBar__Tag DateTagBar__Tag--default">
            <a href="tag/算法.html">算法</a>
          </span>
        
      </div>
    
  </header>
  <article id="https://www.notion.so/6ef0661cc0154378affd1bdf8fb99f3a" class="PageRoot"><h2 id="https://www.notion.so/42af70ccb33b4d22bff45297b66e4ef7" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/42af70ccb33b4d22bff45297b66e4ef7"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">Sort Algorithm</span></span></h2><ol class="NumberedListWrapper"><li id="https://www.notion.so/0924c484fe054b4f990b640dc3ca3d7b" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">Quick Sort</span></span><ul class="BulletedListWrapper"><li id="https://www.notion.so/c943070b8c7f45e28689d9a8611ffc1b" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">与merge sort一样，快速排序也是一种divide and conquer algorithm。它选择一个元素作为pivot，并围绕所选pivot对给定数组进行partition。有以下选择pivot的方式：</span></span><ul class="BulletedListWrapper"><li id="https://www.notion.so/135db7577b374b37a304ec19e263fd1c" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">始终选择第一个元素作为pivot。</span></span></li><li id="https://www.notion.so/b10192dd4eea4f2f953a761268d4901c" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">始终选择最后一个元素作为pivot。</span></span></li><li id="https://www.notion.so/dbac7818d94041259a6ea0b7e457ec19" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">选择一个随机元素作为pivot。</span></span></li><li id="https://www.notion.so/0acb769c9cbd4718bfae9ed62999ecb3" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">选择中位数作为pivot。</span></span><div id="https://www.notion.so/3d41effa6a964bbda03b5b2d8e7a8ce5" class="Image Image--Normal"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F57d09fff-242d-4c53-95ce-e182d654eb68%2FQuickSort.jpg?width=703&amp;table=block&amp;id=3d41effa-6a96-4bbd-a03b-5b2d8e7a8ce5"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F57d09fff-242d-4c53-95ce-e182d654eb68%2FQuickSort.jpg?width=703&amp;table=block&amp;id=3d41effa-6a96-4bbd-a03b-5b2d8e7a8ce5" style="width:703px"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div></li></ul></li><li id="https://www.notion.so/77a9b6c9432e441f860323a529c680b8" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">quickSort 中的关键过程是 partition()。partition的目标是，给定一个数组和数组的一个元素 x 作为 pivot，将 x 放在排序数组中的正确位置并将所有较小的元素（小于 x）放在 x 之前，并将所有更大的元素（大于比 x) 在 x 之后。所有这些都应该在线性时间内完成。</span></span><ul class="BulletedListWrapper"><li id="https://www.notion.so/e4247d11363b4d80a07d194ad01ce36b" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">一种partition的逻辑为，从最左边的元素开始，跟踪较小（或等于）元素的索引为 i。在遍历时，如果我们找到一个更小的元素，我们将当前元素与 arr[i] 交换。否则，我们忽略当前元素。</span></span></li></ul></li></ul><details id="https://www.notion.so/713e9c6fb3224763bf7f6bae29ee456f" class="ColorfulBlock ColorfulBlock--ColorDefault Toggle "><summary class="Toggle__Summary"><span class="SemanticStringArray"><span class="SemanticString">Pseudo Code</span></span></summary><div class="Toggle__Content"><pre id="https://www.notion.so/dccba94d1af84e30b71c844e47d9bcb1" class="Code Code--NoWrap"><code><span class="SemanticStringArray"><span class="SemanticString"><span>Quicksort(A, left, right)
if |A| = 0 then return //A is empty 
end if
split = Partition(A, left, right) 
Quicksort(A, left, split − 1)
Quicksort(A, split + 1, right)

Initial call: Quicksort(A, 1, n)</span></span></span></code></pre><pre id="https://www.notion.so/5745bb2f640f43dda4c5ea002bb57325" class="Code Code--NoWrap"><code><span class="SemanticStringArray"><span class="SemanticString"><span>Partition(A, left, right)
	pivot = A[right]
	split = left − 1

	for j=left to right−1 do
		if A[j] ≤ pivot then 
			swap(A[j], A[split + 1]) 
			split = split + 1
		end if 
	end for

	swap(pivot, A[split + 1])        //place pivot after A[split] (why?) 
	return split + 1                 //the final position of pivot</span></span></span></code></pre><div id="https://www.notion.so/54afb8de49f748e7b07e070c8ac10c6f" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fdbe8e5db-0470-4031-9022-9d86ee88707e%2Fpartition.png?width=1434&amp;table=block&amp;id=54afb8de-49f7-48e7-b07e-070c8ac10c6f"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fdbe8e5db-0470-4031-9022-9d86ee88707e%2Fpartition.png?width=1434&amp;table=block&amp;id=54afb8de-49f7-48e7-b07e-070c8ac10c6f" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div></div></details><details id="https://www.notion.so/fb0f90946b604f86bd7ae6a6904bad41" class="ColorfulBlock ColorfulBlock--ColorDefault Toggle "><summary class="Toggle__Summary"><span class="SemanticStringArray"><span class="SemanticString">Implementation by 选择最后一个元素作为pivot</span></span></summary><div class="Toggle__Content"><pre id="https://www.notion.so/999e4e3f2ae44e75b0152179e62f8a41" class="Code Code--NoWrap"><code><span class="SemanticStringArray"><span class="SemanticString"><span><span class="token comment"># Python3 implementation of QuickSort</span>
<span class="token comment"># Function to find the partition position</span>
<span class="token keyword">def</span> <span class="token function">partition</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">:</span>

	<span class="token comment"># Choose the rightmost element as pivot</span>
	pivot <span class="token operator">=</span> array<span class="token punctuation">[</span>high<span class="token punctuation">]</span>

	<span class="token comment"># Pointer for greater element</span>
	i <span class="token operator">=</span> low <span class="token operator">-</span> <span class="token number">1</span>

	<span class="token comment"># Traverse through all elements</span>
	<span class="token comment"># compare each element with pivot</span>
	<span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">:</span>
		<span class="token keyword">if</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> pivot<span class="token punctuation">:</span>
			<span class="token comment"># If element smaller than pivot is found</span>
			<span class="token comment"># swap it with the greater element pointed by i</span>
			i <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span>

			<span class="token comment"># Swapping element at i with element at j</span>
			<span class="token punctuation">(</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>

	<span class="token comment"># Swap the pivot element with</span>
	<span class="token comment"># e greater element specified by i</span>
	<span class="token punctuation">(</span>array<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> array<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">,</span> array<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

	<span class="token comment"># Return the position from where partition is done</span>
	<span class="token keyword">return</span> i <span class="token operator">+</span> <span class="token number">1</span>

<span class="token comment"># Function to perform quicksort</span>


<span class="token keyword">def</span> <span class="token function">quick_sort</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">:</span>
	<span class="token keyword">if</span> low <span class="token operator">&lt;</span> high<span class="token punctuation">:</span>

		<span class="token comment"># Find pivot element such that</span>
		<span class="token comment"># element smaller than pivot are on the left</span>
		<span class="token comment"># element greater than pivot are on the right</span>
		pi <span class="token operator">=</span> partition<span class="token punctuation">(</span>array<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span>

		<span class="token comment"># Recursive call on the left of pivot</span>
		quick_sort<span class="token punctuation">(</span>array<span class="token punctuation">,</span> low<span class="token punctuation">,</span> pi <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>

		<span class="token comment"># Recursive call on the right of pivot</span>
		quick_sort<span class="token punctuation">(</span>array<span class="token punctuation">,</span> pi <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span></span></span></span></code></pre></div></details><ul class="BulletedListWrapper"><li id="https://www.notion.so/329585ba005d4e6290f495d733ab0ccd" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">Time complexity - </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">O(n*logn)</strong></span></span></li></ul><div id="https://www.notion.so/1a7d6159605e4604af5ac4d159bf84f4" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div></li><li id="https://www.notion.so/1a4b37eadce3438396469c4078cda5c0" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString">Merge Sort - Divide and Conquer</span></span><ul class="BulletedListWrapper"><li id="https://www.notion.so/6a3eefe007db4d22be1643b61c4dd8fe" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">Merge sort 的工作原理是将数组划分为更小的子数组，对每个子数组进行排序，然后将已排序的子数组合并回一起以形成最终的排序数组。</span></span></li><li id="https://www.notion.so/1f1648473c7840adb6c81945496e58a3" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">可以把它想象成一种递归算法，不断地将数组分成两半，直到无法进一步分割为止。</span></span></li></ul><details id="https://www.notion.so/9a0550b6c67e4078b7c5728b12a217f9" class="ColorfulBlock ColorfulBlock--ColorDefault Toggle "><summary class="Toggle__Summary"><span class="SemanticStringArray"><span class="SemanticString">Pseudo Code</span></span></summary><div class="Toggle__Content"><pre id="https://www.notion.so/0b57d019c037419ebd487dd814e273e6" class="Code Code--NoWrap"><code><span class="SemanticStringArray"><span class="SemanticString"><span>step 1: start

step 2: declare array and left, right, mid variable

step 3: perform merge function.
    if left == right
        return
    mid= (left+right)/2
    mergesort(array, left, mid)
    mergesort(array, mid+1, right)
    merge(array, left, mid, right)

step 4: Stop</span></span></span></code></pre><pre id="https://www.notion.so/a9fe3b538b174218b58b7ed33cc7ab2e" class="Code Code--NoWrap"><code><span class="SemanticStringArray"><span class="SemanticString"><span>merge (A, left, right, mid)
	L = A[left, mid]
	R = A[mid + 1, right]
	Maintain two pointers p_L, p_R, initialized to point to the first
	elements of L, R, respectively
	while both lists are nonempty do
		Let x, y be the elements pointed to by </span></span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold"><span>pL, pR</span></strong></span><span class="SemanticString"><span>
		</span></span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold"><span>Compare x, y and append the smaller to the output</span></strong></span><span class="SemanticString"><span>
		</span></span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold"><span>Advance the pointer</span></strong></span><span class="SemanticString"><span> in the list with the smaller of x, y
	end while
	Append the remainder of the non-empty list to the output.

Remark: the output is stored directly in A[left, right], thus the
subarray A[left, right] is sorted after merge(A, left, right, mid).</span></span></span></code></pre><div id="https://www.notion.so/bb1bb3433afb4356b087f5f811eb9b7b" class="Image Image--Normal"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F37bd22e8-be76-4767-8e0c-e5d1d95ab8de%2FmergeSort.jpg?width=657&amp;table=block&amp;id=bb1bb343-3afb-4356-b087-f5f811eb9b7b"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F37bd22e8-be76-4767-8e0c-e5d1d95ab8de%2FmergeSort.jpg?width=657&amp;table=block&amp;id=bb1bb343-3afb-4356-b087-f5f811eb9b7b" style="width:657px"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div></div></details><details id="https://www.notion.so/5e381b9dd4464599a30327a687180fae" class="ColorfulBlock ColorfulBlock--ColorDefault Toggle "><summary class="Toggle__Summary"><span class="SemanticStringArray"><span class="SemanticString">Implementation</span></span></summary><div class="Toggle__Content"><pre id="https://www.notion.so/2377efa57b7f4ad48a2065a622a34b46" class="Code Code--NoWrap"><code><span class="SemanticStringArray"><span class="SemanticString"><span><span class="token comment"># Python program for implementation of MergeSort</span>
<span class="token keyword">def</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span>
	<span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">:</span>

		<span class="token comment"># Finding the mid of the array</span>
		mid <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span>

		<span class="token comment"># Dividing the array elements</span>
		L <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token punctuation">:</span>mid<span class="token punctuation">]</span>

		<span class="token comment"># into 2 halves</span>
		R <span class="token operator">=</span> arr<span class="token punctuation">[</span>mid<span class="token punctuation">:</span><span class="token punctuation">]</span>

		<span class="token comment"># Sorting the first half</span>
		mergeSort<span class="token punctuation">(</span>L<span class="token punctuation">)</span>

		<span class="token comment"># Sorting the second half</span>
		mergeSort<span class="token punctuation">(</span>R<span class="token punctuation">)</span>

		i <span class="token operator">=</span> j <span class="token operator">=</span> k <span class="token operator">=</span> <span class="token number">0</span>

		<span class="token comment"># Copy data to temp arrays L[] and R[]</span>
		<span class="token keyword">while</span> i <span class="token operator">&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span> <span class="token keyword">and</span> j <span class="token operator">&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>R<span class="token punctuation">)</span><span class="token punctuation">:</span>
			<span class="token keyword">if</span> L<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> R<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>
				arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
				i <span class="token operator">+=</span> <span class="token number">1</span>
			<span class="token keyword">else</span><span class="token punctuation">:</span>
				arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> R<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
				j <span class="token operator">+=</span> <span class="token number">1</span>
			k <span class="token operator">+=</span> <span class="token number">1</span>

		<span class="token comment"># Checking if any element was left</span>
		<span class="token keyword">while</span> i <span class="token operator">&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">:</span>
			arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
			i <span class="token operator">+=</span> <span class="token number">1</span>
			k <span class="token operator">+=</span> <span class="token number">1</span>

		<span class="token keyword">while</span> j <span class="token operator">&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>R<span class="token punctuation">)</span><span class="token punctuation">:</span>
			arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> R<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
			j <span class="token operator">+=</span> <span class="token number">1</span>
			k <span class="token operator">+=</span> <span class="token number">1</span></span></span></span></code></pre></div></details><ul class="BulletedListWrapper"><li id="https://www.notion.so/16aabe9bc6a44d9aa708fa1dd5b683e9" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">Time complexity</span></span><div id="https://www.notion.so/7f3385d4a4924138b4cf9c9103b1e2d5" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><span class="SemanticString__Fragment SemanticString__Fragment--Math" data-latex="T(n) = 2T(n/2) + cn"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mi>c</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">T(n) = 2T(n/2) + cn</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span></span></span></span></span></span><span class="SemanticString"> - </span><span class="SemanticString"><span class="SemanticString__Fragment SemanticString__Fragment--Math" data-latex="O(nlogn)"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span></span><span class="SemanticString"> by Master Theorem</span></span></p></div></li></ul></li><li id="https://www.notion.so/7ac59c7cbfe6403f8de34599a5eb7c98" class="NumberedList" value="3"><span class="SemanticStringArray"><span class="SemanticString">Binary Search</span></span><ul class="BulletedListWrapper"><li id="https://www.notion.so/8069e02e49d04e2495c75d5bf75c312b" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">Given a sorted array arr[] of n elements, write a function to search a given element x in arr[] and return the index of x in the array.</span></span></li><li id="https://www.notion.so/e3fd22e434754436b8e832207d07ff6a" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">Algorithm</span></span><ol class="NumberedListWrapper"><li id="https://www.notion.so/5482509257124467a61176c70cb9e6a3" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">将array升序排列。</span></span></li><li id="https://www.notion.so/03db766181434a03ab855989c224dcc6" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString">将第一个元素设为low index，最后一个元素设为high index。</span></span></li><li id="https://www.notion.so/4226eedb1b974eb9996ea30743b3775a" class="NumberedList" value="3"><span class="SemanticStringArray"><span class="SemanticString">将middle index设为 (high + low) / 2</span></span></li><li id="https://www.notion.so/d9552920cdf74c2ba5a5c7d8b954038c" class="NumberedList" value="4"><span class="SemanticStringArray"><span class="SemanticString">如果middle index上的元素就是target，则返回middle。</span></span></li><li id="https://www.notion.so/27eb390f81684ebeb596baaa64eeb854" class="NumberedList" value="5"><span class="SemanticStringArray"><span class="SemanticString">如果target小于middle index上的元素，则将 high 设为 middle - 1。</span></span></li><li id="https://www.notion.so/0e37d1cb06bf4cc0a018b3a172d955e3" class="NumberedList" value="6"><span class="SemanticStringArray"><span class="SemanticString">如果target大于middle index上的元素，则将 low 设为 middle + 1。</span></span></li><li id="https://www.notion.so/c4f96472c9ec45c8949394720e384c90" class="NumberedList" value="7"><span class="SemanticStringArray"><span class="SemanticString">重复3-6直至找到target或者no such target found when no more element。</span></span></li></ol></li></ul><details id="https://www.notion.so/51826b603b5441bdb8a6571c7a36cc00" class="ColorfulBlock ColorfulBlock--ColorDefault Toggle "><summary class="Toggle__Summary"><span class="SemanticStringArray"><span class="SemanticString">Recursive Method</span></span></summary><div class="Toggle__Content"><pre id="https://www.notion.so/066d7f9a9d8743448f07d88316d249d4" class="Code Code--NoWrap"><code><span class="SemanticStringArray"><span class="SemanticString"><span><span class="token comment"># Python3 Program for recursive binary search.</span>

<span class="token comment"># Returns index of x in arr if present, else -1</span>

<span class="token keyword">def</span> <span class="token function">binarySearch</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>

	<span class="token comment"># Check base case</span>
	<span class="token keyword">if</span> r <span class="token operator">>=</span> l<span class="token punctuation">:</span>

		mid <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>

		<span class="token comment"># If element is present at the middle itself</span>
		<span class="token keyword">if</span> arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> x<span class="token punctuation">:</span>
			<span class="token keyword">return</span> mid

		<span class="token comment"># If element is smaller than mid, then it</span>
		<span class="token comment"># can only be present in left subarray</span>
		<span class="token keyword">elif</span> arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> x<span class="token punctuation">:</span>
			<span class="token keyword">return</span> binarySearch<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> l<span class="token punctuation">,</span> mid<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span>

		<span class="token comment"># Else the element can only be present</span>
		<span class="token comment"># in right subarray</span>
		<span class="token keyword">else</span><span class="token punctuation">:</span>
			<span class="token keyword">return</span> binarySearch<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">,</span> x<span class="token punctuation">)</span>

	<span class="token keyword">else</span><span class="token punctuation">:</span>
		<span class="token comment"># Element is not present in the array</span>
		<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span></span></span></span></code></pre></div></details><details id="https://www.notion.so/44276e991ab74306974dc9b43b75b3e0" class="ColorfulBlock ColorfulBlock--ColorDefault Toggle "><summary class="Toggle__Summary"><span class="SemanticStringArray"><span class="SemanticString">Iteration Method</span></span></summary><div class="Toggle__Content"><pre id="https://www.notion.so/c17c277a34474c6e902c14a97abb7d69" class="Code Code--NoWrap"><code><span class="SemanticStringArray"><span class="SemanticString"><span><span class="token keyword">def</span> <span class="token function">binarySearch</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> To_Find<span class="token punctuation">)</span><span class="token punctuation">:</span>
	lo <span class="token operator">=</span> <span class="token number">0</span>
	hi <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>

	<span class="token comment"># This below check covers all cases, so need to check</span>
	<span class="token comment"># for mid=lo-(hi-lo)/2</span>
	<span class="token keyword">while</span> hi <span class="token operator">-</span> lo <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">:</span>
		mid <span class="token operator">=</span> <span class="token punctuation">(</span>hi <span class="token operator">+</span> lo<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>
		<span class="token keyword">if</span> v<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> To_Find<span class="token punctuation">:</span>
			lo <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>
		<span class="token keyword">else</span><span class="token punctuation">:</span>
			hi <span class="token operator">=</span> mid

	<span class="token keyword">if</span> v<span class="token punctuation">[</span>lo<span class="token punctuation">]</span> <span class="token operator">==</span> To_Find<span class="token punctuation">:</span>
		<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Found At Index"</span><span class="token punctuation">,</span> lo<span class="token punctuation">)</span>
	<span class="token keyword">elif</span> v<span class="token punctuation">[</span>hi<span class="token punctuation">]</span> <span class="token operator">==</span> To_Find<span class="token punctuation">:</span>
		<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Found At Index"</span><span class="token punctuation">,</span> hi<span class="token punctuation">)</span>
	<span class="token keyword">else</span><span class="token punctuation">:</span>
		<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Not Found"</span><span class="token punctuation">)</span></span></span></span></code></pre></div></details><ul class="BulletedListWrapper"><li id="https://www.notion.so/56dc2ccf47304ebc98c6611ab14c75f5" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">Running Time</span></span><div id="https://www.notion.so/888c1edc5e284fedaa97dca78e6fb868" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">The time complexity of the binary search algorithm is O(log n). The best-case time complexity would be O(1) when the central index would directly match the desired value. Binary search worst case differs from that. The worst-case scenario could be the values at either extremity of the list or values not in the list.</span></span></p></div></li></ul></li><li id="https://www.notion.so/f309371febe342cbb0a7cd395647078e" class="NumberedList" value="4"><span class="SemanticStringArray"><span class="SemanticString">Insertion Sort</span></span><details id="https://www.notion.so/fc06ab751e7c4c50bf63829983ab00df" class="ColorfulBlock ColorfulBlock--ColorDefault Toggle "><summary class="Toggle__Summary"><span class="SemanticStringArray"><span class="SemanticString">过程</span></span></summary><div class="Toggle__Content"><pre id="https://www.notion.so/55d2efd2699d4e678495c1f49bd27d48" class="Code Code--NoWrap"><code><span class="SemanticStringArray"><span class="SemanticString"><span>该算法通过重复从数组的未排序部分中取出一个元素并将其插入数组已排序部分中的正确位置来对项目数组进行排序。

Input: Array A
n = length(A)
1. 外部 for loop 从索引“1”开始并运行“n-1”次迭代，其中“n”是数组的长度。
2. 内部 while loop从外部 for 循环的当前索引 i 开始，
	 并将每个元素与其左邻居进行比较。 如果一个元素小于它的左邻居，则交换元素。
3. 内部 while loop 继续将元素向左移动，直到它小于其左侧的元素停止while loop。
4. 内部 while loop 完成后，当前索引&quot;j&quot;处的元素即为数组已排序部分中的正确位置。
5. 外层的 for 循环继续遍历数组，直到所有元素都在正确的位置并且数组已完全排序。</span></span></span></code></pre><pre id="https://www.notion.so/6f95535a947d4e89859853e65d79ede8" class="Code Code--NoWrap"><code><span class="SemanticStringArray"><span class="SemanticString"><span>insertionSort<span class="token punctuation">(</span>A<span class="token punctuation">:</span> <span class="token builtin">list</span> of sortable items<span class="token punctuation">)</span>
   n <span class="token operator">=</span> length<span class="token punctuation">(</span>A<span class="token punctuation">)</span>
   <span class="token keyword">for</span> i <span class="token operator">=</span> <span class="token number">1</span> to n <span class="token operator">-</span> <span class="token number">1</span> do
       j <span class="token operator">=</span> i
       <span class="token keyword">while</span> j <span class="token operator">></span> <span class="token number">0</span> <span class="token keyword">and</span> A<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> A<span class="token punctuation">[</span>j<span class="token punctuation">]</span> do
           swap<span class="token punctuation">(</span>A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> A<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
           j <span class="token operator">=</span> j <span class="token operator">-</span> <span class="token number">1</span>
       end <span class="token keyword">while</span>
   end <span class="token keyword">for</span>
end algorithm</span></span></span></code></pre></div></details><ul class="BulletedListWrapper"><li id="https://www.notion.so/c265bf5b295d42d2aa8287211beaa38a" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">Time complexity - O(N^2)</span></span></li></ul></li></ol><h2 id="https://www.notion.so/0136b478ed66449482e8da3fbffd2d22" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/0136b478ed66449482e8da3fbffd2d22"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">Graph Algorithm</span></span></h2><ol class="NumberedListWrapper"><li id="https://www.notion.so/da9b183e02c24aa088b51c409dc0c549" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">BFS 广度优先搜索</span></span><ul class="BulletedListWrapper"><li id="https://www.notion.so/de938419c1984ffc9d0ad1b212e3a144" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">Breadth-first search (BFS): explore G starting from s outward in all possible directions, adding reachable nodes one layer at a time.</span></span><ul class="BulletedListWrapper"><li id="https://www.notion.so/db9d644490274b94ab2daa154fe7564e" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">First add all nodes that are joined by an edge to the source: these nodes form the first layer.
If G is unweighted, these are the nodes at distance 1 from s.</span></span></li><li id="https://www.notion.so/a80c96bf2e564d7e91fc358c916f167b" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">Then add all nodes that are joined by an edge to a node in the first layer: these nodes form the second layer.</span></span></li><li id="https://www.notion.so/019c2e64ee674ca1a0569e175a4d2a28" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">If G is unweighted, these are the nodes at distance 2 from s.</span></span></li><li id="https://www.notion.so/eaf2702f264c447b82ae3fd51c8ef9e8" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">And so on and so forth.</span></span></li></ul></li><li id="https://www.notion.so/fd405e3cb79b4c28b72b4bd674457d00" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">Facts of BFS</span></span><ul class="BulletedListWrapper"><li id="https://www.notion.so/20ef9133633045e29528764adbb7027d" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><span class="SemanticString__Fragment SemanticString__Fragment--Math" data-latex="L_i"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">L_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></span><span class="SemanticString"> is the set of nodes that are at distance </span><span class="SemanticString"><span class="SemanticString__Fragment SemanticString__Fragment--Math" data-latex="i"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span></span></span><span class="SemanticString"> from s. Equivalently, the length of the shortest s-v path for all </span><span class="SemanticString"><span class="SemanticString__Fragment SemanticString__Fragment--Math" data-latex="v ∈ L_i"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo>∈</mo><msub><mi>L</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v ∈ L_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></span><span class="SemanticString"> equals </span><span class="SemanticString"><span class="SemanticString__Fragment SemanticString__Fragment--Math" data-latex="i"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span></span></span><span class="SemanticString">.</span></span></li></ul></li></ul><details id="https://www.notion.so/94646a92c4ab4e6da7ce4d011816a552" class="ColorfulBlock ColorfulBlock--ColorDefault Toggle "><summary class="Toggle__Summary"><span class="SemanticStringArray"><span class="SemanticString">Pseudo Code with explanation</span></span></summary><div class="Toggle__Content"><pre id="https://www.notion.so/039fb4ba40ae4964ac89c4f045d29a51" class="Code Code--NoWrap"><code><span class="SemanticStringArray"><span class="SemanticString"><span>BFS(G = (V, E), s ∈ V )
	# discovered array表示一个vertex是否已被访问过
	# 如果被访问过则记为1，没有则记为0
	array discovered[V] initialized all vertices to 0 ---- O(n)

	# The dist array记录了source到每一个vertex的最短路径
	# 除了source自身，所有vertex的初始路径都为无穷大
	array dist[V] initialized to infinity array ---- O(n)

	# The parent array记录了每一个vertex的parent
	parent[V] initialized to NIL ---- O(n)

	# q记录正在被处理或者当前被访问的vertices
	queue q ---- O(1)

	# Initialize with source ---- O(1)
	discovered[s] = 1
	dist[s] = 0
	parent[s] = NIL

	# 因为source是第一个visited的vertex, 将当前要处理的vertex s加入queue
	enqueue(q, s) ---- O(1)

	# 当当前需要处理的queue不为空时
	while size(q)&gt;0 do
	# 取出第一个vertex &#x27;u&#x27;并检索所有从&#x27;u&#x27;延伸出的edges(u, v)
	u =dequeue(q)
		# 对于每一个与&#x27;u&#x27;相连的vertex &#x27;v&#x27;
		for (u, v) ∈ E do
		# 如果&#x27;v&#x27;还未被访问过，即discovered[v] == 0
			if discovered[v] == 0 then 
				# 则标记&#x27;v&#x27;为已访问过，即discovered[v] == 1
				discovered[v] = 1
				# 对于unweighted graph，source到&#x27;v&#x27;的距离 = source到&#x27;u&#x27;的距离 + 1
				dist[v] = dist[u] + 1
				# 更新当前vertex &#x27;v&#x27;的parent为&#x27;u&#x27;
				parent[v] = u
				# 把&#x27;v&#x27;添加进q作为下一个layer要检索的vertex
				enqueue(q, v)
				# 如果vertex&#x27;v&#x27;已被访问过，则进入下一个for loop检索未被访问的&#x27;v&#x27;
			end if 
		end for
	end while</span></span></span></code></pre></div></details><ul class="BulletedListWrapper"><li id="https://www.notion.so/d6973fbad9ec4413990d0182026c3408" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">Time complexity analysis</span></span><div id="https://www.notion.so/4cb9ca1da0ac462b84d28ce485d30872" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">前面初始化部分的时间复杂度为O(n)，因为只需要遍历每个节点一次。对于while循环来讲，q的最大数量就是vertices的总数，所以while loop不会超过|V|次迭代，即O(|V|)。对于for loop，检索每一个和’u’临近的节点v，显然不会超过|E|次迭代，这一步的时间实际上与’u’的degrees成比例。因此，检查图中与所有顶点相邻的所有边所花费的总时间与所有顶点的degrees之和成正比，即 2|E| (因为每条边都对恰好两个顶点)。</span></span></p></div><div id="https://www.notion.so/fa109c19a8e84e7997226c0e280a8c97" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">综上所述，BFS的时间复杂度为O(|V| + |E|)。</span></span></p></div></li></ul><details id="https://www.notion.so/b5c3adec0d4f4605bf2d1481c22063b8" class="ColorfulBlock ColorfulBlock--ColorDefault Toggle "><summary class="Toggle__Summary"><span class="SemanticStringArray"><span class="SemanticString">Implementation - without tracking the distance and parent</span></span></summary><div class="Toggle__Content"><pre id="https://www.notion.so/065f1ae2297848eba8ddee4fb2f319ac" class="Code Code--NoWrap"><code><span class="SemanticStringArray"><span class="SemanticString"><span><span class="token comment"># Python3 Program to print BFS traversal</span>
<span class="token comment"># from a given source vertex. BFS(int s)</span>
<span class="token comment"># traverses vertices reachable from s.</span>
<span class="token keyword">from</span> collections <span class="token keyword">import</span> defaultdict

<span class="token comment"># This class represents a directed graph</span>
<span class="token comment"># using adjacency list representation</span>


<span class="token keyword">class</span> <span class="token class-name">Graph</span><span class="token punctuation">:</span>

	<span class="token comment"># Constructor</span>
	<span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>

		<span class="token comment"># default dictionary to store graph</span>
		self<span class="token punctuation">.</span>graph <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span><span class="token builtin">list</span><span class="token punctuation">)</span>

	<span class="token comment"># function to add an edge to graph</span>
	<span class="token keyword">def</span> <span class="token function">addEdge</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> u<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">:</span>
		self<span class="token punctuation">.</span>graph<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>v<span class="token punctuation">)</span>

	<span class="token comment"># Function to print a BFS of graph</span>
	<span class="token keyword">def</span> <span class="token function">BFS</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">:</span>

		<span class="token comment"># Mark all the vertices as not visited</span>
		visited <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token boolean">False</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token builtin">max</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>graph<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>

		<span class="token comment"># Create a queue for BFS</span>
		queue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

		<span class="token comment"># Mark the source node as</span>
		<span class="token comment"># visited and enqueue it</span>
		queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>s<span class="token punctuation">)</span>
		visited<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">True</span>

		<span class="token keyword">while</span> queue<span class="token punctuation">:</span>

			<span class="token comment"># Dequeue a vertex from</span>
			<span class="token comment"># queue and print it</span>
			s <span class="token operator">=</span> queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
			<span class="token keyword">print</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">" "</span><span class="token punctuation">)</span>

			<span class="token comment"># Get all adjacent vertices of the</span>
			<span class="token comment"># dequeued vertex s. If a adjacent</span>
			<span class="token comment"># has not been visited, then mark it</span>
			<span class="token comment"># visited and enqueue it</span>
			<span class="token keyword">for</span> i <span class="token keyword">in</span> self<span class="token punctuation">.</span>graph<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">:</span>
				<span class="token keyword">if</span> visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token boolean">False</span><span class="token punctuation">:</span>
					queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span>
					visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">True</span></span></span></span></code></pre></div></details><details id="https://www.notion.so/2fcb117c1b7d49d6be755c9e4b76ae74" class="ColorfulBlock ColorfulBlock--ColorDefault Toggle "><summary class="Toggle__Summary"><span class="SemanticStringArray"><span class="SemanticString">应用</span></span></summary><div class="Toggle__Content"><ul class="BulletedListWrapper"><li id="https://www.notion.so/f032449ed0e84bdda373434e9d04d78f" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">1. A natural way to solve 2-colorability(bipartite-ness)</span></span><ul class="BulletedListWrapper"><li id="https://www.notion.so/4ee7765673dc421ab7f98079b2216dc1" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">If a graph contains an odd-length cycle, then it is not 2-colorable.</span></span></li></ul><pre id="https://www.notion.so/40f6b80d0872491ab2c7d6feb1573c5f" class="Code Code--NoWrap"><code><span class="SemanticStringArray"><span class="SemanticString"><span>bipartite(G = (V,E))
	1. Start BFS from any vertex; color it red.
	2. Color white all nodes in the first layer L1 of the BFS tree.
	If there is an edge between two nodes in L1, output </span></span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold"><span>no</span></strong></span><span class="SemanticString"><span> and stop.
	3. Otherwise, continue from layer L1, coloring red the vertices
	in even layers and white in odd layers.
	4. If BFS terminates and all nodes in V have been explored 
	(hence 2-colored), output </span></span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold"><span>yes</span></strong></span><span class="SemanticString"><span>.</span></span></span></code></pre></li><li id="https://www.notion.so/ed7372d4f6f44650951e423e4ac46556" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">2. 找到所有的SCC</span></span><pre id="https://www.notion.so/4161c52629a84ee8a741c5c57929fae0" class="Code Code--NoWrap"><code><span class="SemanticStringArray"><span class="SemanticString"><span>AllConnectedComponents(G = (V, E))
	1. Start with an arbitrary node s; run BFS(G, s) and output
	the resulting BFS tree as one connected component.
	2. Continue with any node u that has not been visited by
	BFS(G, s); run BFS from u and output the resulting BFS
	tree as one connected component.
	3. Repeat until all nodes in V have been visited.</span></span></span></code></pre></li></ul></div></details></li></ol><div id="https://www.notion.so/53c4810e034741edadd5e26e5c6c8423" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><div id="https://www.notion.so/4d619a773d074fd09d7f1e6f852af919" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div><ol class="NumberedListWrapper"><li id="https://www.notion.so/c400020d562544b4b5849e6d00844eed" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">DFS 深度优先搜索</span></span><ul class="BulletedListWrapper"><li id="https://www.notion.so/fcc9aec0a8f247aea71ce786f31551f4" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">Depth-first search is an algorithm for traversing or searching tree or graph data structures. The algorithm starts at the root node (selecting some arbitrary node as the root node in the case of a graph) and </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">explores</strong></span><span class="SemanticString"> </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">as far as possible along each branch before backtracking</strong></span><span class="SemanticString">.</span></span></li><li id="https://www.notion.so/b5738160fadb4872b77fd59bdfd25ec8" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">Basic idea:</strong></span><span class="SemanticString"> Start from the root or any arbitrary node and mark the node and move to the adjacent unmarked node and continue this loop until there is no unmarked adjacent node. Then backtrack and check for other unmarked nodes and traverse them. Finally, print the nodes in the path.</span></span></li></ul><details id="https://www.notion.so/01d1cddc75fe4efe9aefd6749794f1d6" class="ColorfulBlock ColorfulBlock--ColorDefault Toggle "><summary class="Toggle__Summary"><span class="SemanticStringArray"><span class="SemanticString">Algorithm with explanation</span></span></summary><div class="Toggle__Content"><pre id="https://www.notion.so/5d74b72ae2d74c3b8ce2ebd03c827755" class="Code Code--NoWrap"><code><span class="SemanticStringArray"><span class="SemanticString"><span># array explored来记录一个vertex是否已被访问
DFS(G = (V, E)) 
	# Initialize the global variable time to 0
	time = 0
	# 对于每一个V中的vertex，标记每一个vertex的初始状态为未被访问
	for u ∈ V do
		explored[u] = 0 
	end for
	
	# 对于每一个V中的vertex u
	for u ∈ V do
		# 如果&#x27;u&#x27;尚未被访问，则call检索function search(u)
		if explored[u] == 0 then 
			Search(u) 
		end if
	end for

Search(u) 
	previsit(u)
	#更改&#x27;u&#x27;的标记为已被访问
	explored[u] = 1 
	# 对于每一个与&#x27;u&#x27;相连的vertex &#x27;v&#x27;
	for (u, v) ∈ E do
		# 如果&#x27;v&#x27;未被访问，则call search(v)
		if explored[v] == 0 then 
			Search(v)
		end if 
	end for
	postvisit(u)

# start(u) is the time when u is pushed in the stack
# finish(u) is the time when u is popped from the stack

previsit(u)
	time += 1
	start(u) = time
	push(stack, u)

postvisit(u)
	time += 1
	finish(u) = time
	pop(stack, u)</span></span></span></code></pre><div id="https://www.notion.so/391b35d6fea84450829afcf541ff61f1" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">Here is a flow chart of how this algorithm works.</span></span></p></div><div id="https://www.notion.so/2e56983a351d49378a1ed001ecfe153d" class="Image Image--PageWidth"><figure><a href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F94bdbeaa-f9ea-4bc7-8969-dc9502206dc5%2FDFS_flow.jpeg?width=1668&amp;table=block&amp;id=2e56983a-351d-4937-8a1e-d001ecfe153d"><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F94bdbeaa-f9ea-4bc7-8969-dc9502206dc5%2FDFS_flow.jpeg?width=1668&amp;table=block&amp;id=2e56983a-351d-4937-8a1e-d001ecfe153d" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div></div></details><ul class="BulletedListWrapper"><li id="https://www.notion.so/226f66a532de4237b92245950d904792" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">Time complexity analysis</span></span><div id="https://www.notion.so/12fb5cf67ed2471899c38ad912041bf3" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">The time complexity of the DFS algorithm is O(|V| + |E|), where |V| is the number of vertices in the graph, and |E| is the number of edges in the graph. The initialization of the &#x27;explored&#x27; array takes O(|V|) time, and the Search function is called for each vertex in the graph, which takes O(|V|) time. The total time taken to examine all edges in the graph is proportional to the sum of the degrees of all vertices, which is 2|E|. Therefore, the time complexity of examining all edges in the graph is O(|E|). Overall, the time complexity of the DFS algorithm is O(|V| + |E|).</span></span></p></div></li></ul><details id="https://www.notion.so/07f7c8c2cc0e498abef9b3534af978d6" class="ColorfulBlock ColorfulBlock--ColorDefault Toggle "><summary class="Toggle__Summary"><span class="SemanticStringArray"><span class="SemanticString"> Implementation</span></span></summary><div class="Toggle__Content"><pre id="https://www.notion.so/853f69acb55b4f8d91c4d314adac7fd4" class="Code Code--NoWrap"><code><span class="SemanticStringArray"><span class="SemanticString"><span><span class="token comment"># Python3 program to print DFS traversal</span>
<span class="token comment"># from a given graph</span>
<span class="token keyword">from</span> collections <span class="token keyword">import</span> defaultdict

<span class="token comment"># This class represents a directed graph using</span>
<span class="token comment"># adjacency list representation</span>


<span class="token keyword">class</span> <span class="token class-name">Graph</span><span class="token punctuation">:</span>

	<span class="token comment"># Constructor</span>
	<span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>

		<span class="token comment"># default dictionary to store graph</span>
		self<span class="token punctuation">.</span>graph <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span><span class="token builtin">list</span><span class="token punctuation">)</span>

	<span class="token comment"># function to add an edge to graph</span>
	<span class="token keyword">def</span> <span class="token function">addEdge</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> u<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">:</span>
		self<span class="token punctuation">.</span>graph<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>v<span class="token punctuation">)</span>

	<span class="token comment"># A function used by DFS</span>
	<span class="token keyword">def</span> <span class="token function">DFSUtil</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> v<span class="token punctuation">,</span> visited<span class="token punctuation">)</span><span class="token punctuation">:</span>

		<span class="token comment"># Mark the current node as visited</span>
		<span class="token comment"># and print it</span>
		visited<span class="token punctuation">.</span>add<span class="token punctuation">(</span>v<span class="token punctuation">)</span>
		<span class="token keyword">print</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">' '</span><span class="token punctuation">)</span>

		<span class="token comment"># Recur for all the vertices</span>
		<span class="token comment"># adjacent to this vertex</span>
		<span class="token keyword">for</span> neighbour <span class="token keyword">in</span> self<span class="token punctuation">.</span>graph<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">:</span>
			<span class="token keyword">if</span> neighbour <span class="token keyword">not</span> <span class="token keyword">in</span> visited<span class="token punctuation">:</span>
				self<span class="token punctuation">.</span>DFSUtil<span class="token punctuation">(</span>neighbour<span class="token punctuation">,</span> visited<span class="token punctuation">)</span>

	<span class="token comment"># The function to do DFS traversal. It uses</span>
	<span class="token comment"># recursive DFSUtil()</span>
	<span class="token keyword">def</span> <span class="token function">DFS</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">:</span>

		<span class="token comment"># Create a set to store visited vertices</span>
		visited <span class="token operator">=</span> <span class="token builtin">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

		<span class="token comment"># Call the recursive helper function</span>
		<span class="token comment"># to print DFS traversal</span>
		self<span class="token punctuation">.</span>DFSUtil<span class="token punctuation">(</span>v<span class="token punctuation">,</span> visited<span class="token punctuation">)</span></span></span></span></code></pre></div></details><ul class="BulletedListWrapper"><li id="https://www.notion.so/5a8a65ba7eec4372a4be7dc8bdff594e" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">应用</span></span><ul class="BulletedListWrapper"><li id="https://www.notion.so/eafe8b694bef4dd2a66102eac149f407" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">1. 检测cycle: G = (V, E) has a cycle if and only if DFS(G) yields a </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">back edge</strong></span><span class="SemanticString">.</span></span></li><li id="https://www.notion.so/5d66cddbec95468b943664633bc88dac" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">2. Topological sorting in DAGs (DAG - Directed acyclic graph)</span></span></li></ul></li></ul></li><li id="https://www.notion.so/64770145a3bf44d8ad9eb6e8e5b33c5f" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString">Dijkstra - The shortest path from a source to all vertices - </span><span class="SemanticString"><mark class="SemanticString__Fragment SemanticString__Fragment--HighlightedColor SemanticString__Fragment--ColorRed"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">TODO</strong></mark></span></span><ul class="BulletedListWrapper"><li id="https://www.notion.so/abc2d000026945909531a370e61f1953" class="BulletedList"><span class="SemanticStringArray"><span class="SemanticString">Given a graph and a source vertex in the graph, find the </span><span class="SemanticString"><strong class="SemanticString__Fragment SemanticString__Fragment--Bold">shortest paths </strong></span><span class="SemanticString">from the source to all vertices in the given graph.</span></span></li></ul><details id="https://www.notion.so/494259185bbd401da7f33fd8c876c4d7" class="ColorfulBlock ColorfulBlock--ColorDefault Toggle "><summary class="Toggle__Summary"><span class="SemanticStringArray"><span class="SemanticString">Pseudocode with an explanation - Greedy Algorithm</span></span></summary><div class="Toggle__Content"><pre id="https://www.notion.so/04c293e4494e4504afea1091a974d329" class="Code Code--NoWrap"><code><span class="SemanticStringArray"><span class="SemanticString"><span>Dijkstra-v1(G = (V, E, w), s ∈ V) 

	Initialize(G, s)

	</span></span><span class="SemanticString"><mark class="SemanticString__Fragment SemanticString__Fragment--HighlightedColor SemanticString__Fragment--ColorBlue"><span># Initialize the set S with only source vertex s.</span></mark></span><span class="SemanticString"><span>
	S = {s}

	</span></span><span class="SemanticString"><mark class="SemanticString__Fragment SemanticString__Fragment--HighlightedColor SemanticString__Fragment--ColorBlue"><span># This loop continues until S contains all vertices in the graph.</span></mark></span><span class="SemanticString"><span>
	while S != V do
</span></span><span class="SemanticString"><mark class="SemanticString__Fragment SemanticString__Fragment--HighlightedColor SemanticString__Fragment--ColorBlue"><span>		# This loop iterates over all vertices x 
		# that are not in S and have at least one edge from S.
</span></mark></span><span class="SemanticString"><span>		For every x ∈ V − S with at least one edge from S compute
			d(x) = min {dist[u] + w_{ux}}
					u ∈ S,(u,x) ∈ E
		Select v such that d(v) = min d(x)
														x ∈ V−S
		S = S ∪ {v} 
		dist[v] = d(v) 
		prev[v] = u
	end while

</span></span><span class="SemanticString"><mark class="SemanticString__Fragment SemanticString__Fragment--HighlightedColor SemanticString__Fragment--ColorBlue"><span># This function initializes the distances and predecessors of all vertices in the graph. 
# It sets the distance of the source vertex s to 0 and the distance of all other vertices to infinity.</span></mark></span><span class="SemanticString"><span>
Initialize(G, s) 
	for v ∈ V do
		dist[v] = ∞
		prev[v] = NIL 
	end for
	dist[s] = 0</span></span></span></code></pre></div></details></li><li id="https://www.notion.so/677dd20e4cea4b9d8d89c5fb558f0fa0" class="NumberedList" value="3"><span class="SemanticStringArray"><span class="SemanticString">二叉树遍历算法 - 基本思想：递归</span></span><ol class="NumberedListWrapper"><li id="https://www.notion.so/cd1ea279d56a4024a86faeffa9f85c42" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">前序遍历 - Preorder</span></span><ol class="NumberedListWrapper"><li id="https://www.notion.so/a782c3b7d6bb4b82a89e2fa365359895" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">根结点 ---&gt; 左子树 ---&gt; 右子树</span></span></li></ol><pre id="https://www.notion.so/1817181e342343f3871627e485914830" class="Code Code--NoWrap"><code><span class="SemanticStringArray"><span class="SemanticString"><span><span class="token keyword">def</span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> root <span class="token operator">!=</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
        <span class="token comment"># Visit the root node</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
        <span class="token comment"># Recursively traverse the left subtree</span>
        preorderTraversal<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
        <span class="token comment"># Recursively traverse the right subtree</span>
        preorderTraversal<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span></span></span></span></code></pre></li><li id="https://www.notion.so/8444a9011e474c0dbab2249f5686faeb" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString">中序遍历 - Inorder</span></span><ol class="NumberedListWrapper"><li id="https://www.notion.so/cbb510f74e314ff49dc471a0eb776980" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">左子树 ---&gt; 根结点 ---&gt; 右子树</span></span></li></ol><pre id="https://www.notion.so/bade0be6ad8c4291905b745574ade5ac" class="Code Code--NoWrap"><code><span class="SemanticStringArray"><span class="SemanticString"><span><span class="token keyword">def</span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> root <span class="token operator">!=</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
        <span class="token comment"># Recursively traverse the left subtree</span>
        inorderTraversal<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
        <span class="token comment"># Visit the root node</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
        <span class="token comment"># Recursively traverse the right subtree</span>
        inorderTraversal<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span></span></span></span></code></pre></li><li id="https://www.notion.so/d1883da8841c488fa976fe278cfef318" class="NumberedList" value="3"><span class="SemanticStringArray"><span class="SemanticString">后序遍历 - Postorder</span></span><ol class="NumberedListWrapper"><li id="https://www.notion.so/2c38d5ccae4242c58a74a9882f0087f4" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">左子树 ---&gt; 右子树 ---&gt; 根结点</span></span></li></ol><pre id="https://www.notion.so/cc0032bf3949432185f751437525c620" class="Code Code--NoWrap"><code><span class="SemanticStringArray"><span class="SemanticString"><span><span class="token keyword">def</span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> root <span class="token operator">!=</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
        <span class="token comment"># Recursively traverse the left subtree</span>
        postorderTraversal<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
        <span class="token comment"># Recursively traverse the right subtree</span>
        postorderTraversal<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
        <span class="token comment"># Visit the root node</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span></span></span></span></code></pre></li></ol></li></ol><h2 id="https://www.notion.so/599ceb02c00c4570b84f294338ae8557" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/599ceb02c00c4570b84f294338ae8557"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">Dynamic Programming</span></span></h2></article>
  <footer class="Footer">
  <div>&copy; Welcome to Robin’s Blog 2022</div>
  <div>&centerdot;</div>
  <div>Powered by <a href="https://github.com/dragonman225/notablog" target="_blank"
      rel="noopener noreferrer">Notablog</a>.
  </div>
</footer>
</body>

</html>